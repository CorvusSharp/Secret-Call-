<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1, viewport-fit=cover">
  <title>Secure Call ‚Äî Group</title>
  <link rel="icon" href="/icon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="/style.css">
  <meta name="color-scheme" content="dark light">
</head>
<body>
  <!-- –ü–∞—Ä—Ç–∏–∫–ª—ã (canvas) -->
  <canvas id="bg-particles" aria-hidden="true"></canvas>

  <!-- –ñ–∏–≤—ã–µ –≥—Ä–∞–¥–∏–µ–Ω—Ç—ã / –ø–µ—Ä–µ–ª–∏–≤—ã -->
  <div class="blob-layer" aria-hidden="true">
    <span class="blob b1"></span>
    <span class="blob b2"></span>
    <span class="blob b3"></span>
  </div>

  <!-- –û—Å–Ω–æ–≤–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ -->
  <main class="wrap">
    <section class="card glass rise">
      <header class="card__header">
        <img class="brand" src="/icon.svg" alt="Secure Call" width="28" height="28">
        <h1 class="title">Secure Call</h1>
      </header>

      <p class="muted">
        –í–≤–µ–¥–∏—Ç–µ –∏–º—è –∏ –ø–æ–¥–∫–ª—é—á–∞–π—Ç–µ—Å—å. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–∏–∂–µ ‚Äî <b>–ª–æ–∫–∞–ª—å–Ω—ã–µ</b> (–Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –¥—Ä—É–≥–∏—Ö).
      </p>

      <div class="row join-row">
        <input id="name" class="input" placeholder="–í–∞—à–µ –∏–º—è" maxlength="32" autocomplete="name">
        <!-- –û–î–ù–ê –ö–ù–û–ü–ö–ê: –í–æ–π—Ç–∏ ‚áÑ –í—ã–π—Ç–∏ -->
        <button id="join" class="btn primary glow" aria-pressed="false" data-mode="join">
          <span class="btn__label">–í–æ–π—Ç–∏</span>
        </button>
        <button id="settings" class="btn subtle" title="–°–µ—Ç–µ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (STUN)" aria-pressed="false">‚öôÔ∏é</button>
      </div>

      <!-- –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç—É—Å–∞ -->
      <div class="statusbar" id="statusbar">
        <span id="state" class="state-dot">–ù–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ</span>
      </div>

      <!-- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –ø–∏—Ä–æ–≤ -->
      <div id="peers" class="peers-grid"></div>

      <!-- –ß–∞—Ç -->
      <section class="chat" aria-label="–ì—Ä—É–ø–ø–æ–≤–æ–π —á–∞—Ç">
        <div id="chat-log" class="chat__log" role="log" aria-live="polite"></div>
        <div class="chat__row">
          <div id="mentions-suggest" class="mentions-suggest" hidden></div>
          <input id="chat-input" class="input" placeholder="–ù–∞–ø–∏—à–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –Ω–∞–∂–º–∏—Ç–µ Enter‚Ä¶">
          <button id="emoji-btn" class="emoji-btn" title="–≠–º–æ–¥–∑–∏">üòä</button>
          <button id="chat-send" class="btn send">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
          <div id="emoji-pop" class="emoji-pop" hidden></div>
        </div>
      </section>

      <!-- –ú–∏–Ω–∏-—Ö–µ–ª–ø -->
      <details class="help">
        <summary>–ü–æ–¥—Å–∫–∞–∑–∫–∏</summary>
        <ul>
          <li>–ü–æ–ª–∑—É–Ω–æ–∫ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –≤–∞—à–∏–º–∏ –∫–æ–ª–æ–Ω–∫–∞–º–∏.</li>
          <li>–ö–Ω–æ–ø–∫–∞ <b>Mute</b> –≥–ª—É—à–∏—Ç –∑–≤—É–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ —É –≤–∞—Å.</li>
          <li>–ï—Å–ª–∏ –∫–æ–º–Ω–∞—Ç–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞ ‚Äî –ø–æ—è–≤–∏—Ç—Å—è –æ–∫–Ω–æ —Å –ø–æ—è—Å–Ω–µ–Ω–∏–µ–º.</li>
        </ul>
      </details>
    </section>
  </main>

  <!-- –®–∞–±–ª–æ–Ω –∫–∞—Ä—Ç–æ—á–∫–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞ -->
  <template id="peer-tpl">
    <article class="peer">
      <div class="peer__hdr">
        <span class="peer__name"></span>
        <div class="peer__actions">
          <button class="btn micro mute" aria-pressed="false">Mute</button>
        </div>
      </div>
      <audio autoplay playsinline></audio>
      <div class="peer__ctrls">
        <label class="slider">
          <span>–ì—Ä–æ–º–∫–æ—Å—Ç—å</span>
          <input type="range" min="0" max="200" value="100" class="vol">
        </label>
      </div>
    </article>
  </template>

  <!-- –ú–æ–¥–∞–ª–∫–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è / –±—Ä–∞—É–∑–µ—Ä–∞ -->
  <div id="join-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="join-modal-title">
    <div class="modal__card glass">
      <h2 id="join-modal-title" class="modal__title">–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</h2>
      <p id="join-modal-text" class="modal__text">
        –ö–æ–º–Ω–∞—Ç–∞ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∞. –°–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç –Ω–µ—Ç.
      </p>
      <div class="modal__actions">
        <button id="join-modal-ok" class="btn primary">–û–∫</button>
      </div>
    </div>
  </div>

  <!-- –ü–∞–Ω–µ–ª—å —Å–µ—Ç–µ–≤—ã—Ö –Ω–∞—Å—Ç—Ä–æ–µ–∫ -->
  <div id="net-popover" class="popover hidden" role="dialog" aria-modal="true" aria-labelledby="net-popover-title">
    <div class="popover__card glass">
      <h3 id="net-popover-title">–°–µ—Ç–µ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
      <label class="stack">
        <span>STUN URL (–¥–ª—è WebRTC):</span>
        <input id="stun-input" class="input" placeholder="stun:stun.l.google.com:19302">
      </label>
      <div class="row end">
        <button id="stun-reset" class="btn subtle">–°–±—Ä–æ—Å–∏—Ç—å</button>
        <button id="stun-save" class="btn primary">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
      </div>
    </div>
  </div>

  <!-- –¢–æ—Å—Ç—ã -->
  <div id="toasts" class="toasts" aria-live="polite"></div>

  <script>
  // ---------- –ü–∞—Ä—Ç–∏–∫–ª—ã (—Ñ–æ–Ω) ----------
  (function () {
    const canvas = document.getElementById('bg-particles');
    const ctx = canvas.getContext('2d', { alpha: true });
    const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    let W = 0, H = 0, particles = [];
    function resize() {
      W = canvas.width = Math.floor(window.innerWidth * DPR);
      H = canvas.height = Math.floor(window.innerHeight * DPR);
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      spawn();
    }
    function spawn() {
      const count = Math.floor((W * H) / (130 * 130) * 0.75);
      particles = Array.from({ length: count }, () => ({
        x: Math.random() * W,
        y: Math.random() * H,
        r: 0.8 + Math.random() * 1.8,
        a: 0.15 + Math.random() * 0.5,
        vx: (Math.random() - 0.5) * 0.25 * DPR,
        vy: (Math.random() - 0.5) * 0.25 * DPR,
      }));
    }
    function step() {
      ctx.clearRect(0, 0, W, H);
      for (const p of particles) {
        p.x += p.vx; p.y += p.vy;
        if (p.x < -5) p.x = W + 5; if (p.x > W + 5) p.x = -5;
        if (p.y < -5) p.y = H + 5; if (p.y > H + 5) p.y = -5;
        const hue = (p.x / W) * 360;
        ctx.beginPath();
        ctx.fillStyle = `hsla(${hue}, 90%, 60%, ${p.a})`;
        ctx.arc(p.x, p.y, p.r * DPR, 0, Math.PI * 2);
        ctx.fill();
      }
      requestAnimationFrame(step);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize(); step();
  })();

  // ---------- –£—Ç–∏–ª–∏—Ç—ã UI ----------
  const $ = (sel, root = document) => root.querySelector(sel);
  const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
  function toast(text, type = 'info') {
    const box = document.createElement('div');
    box.className = `toast ${type}`;
    box.textContent = text;
    $('#toasts').appendChild(box);
    setTimeout(() => box.classList.add('show'), 10);
    setTimeout(() => { box.classList.remove('show'); setTimeout(()=>box.remove(), 400); }, 3500);
  }

  // Ripple —ç—Ñ—Ñ–µ–∫—Ç
  document.addEventListener('pointerdown', (e) => {
    const btn = e.target.closest('.btn'); if (!btn) return;
    btn.classList.add('is-pressed');
    const rect = btn.getBoundingClientRect();
    const r = Math.max(rect.width, rect.height);
    const x = e.clientX - rect.left, y = e.clientY - rect.top;
    const wave = document.createElement('span');
    wave.className = 'ripple';
    wave.style.left = (x - r/2) + 'px';
    wave.style.top  = (y - r/2) + 'px';
    wave.style.width = wave.style.height = r + 'px';
    btn.appendChild(wave);
    setTimeout(()=> wave.remove(), 600);
  }, { passive: true });
  ['pointerup','pointerleave','blur'].forEach(ev => {
    document.addEventListener(ev, (e)=>{
      const btn = e.target.closest?.('.btn'); if (!btn) return;
      btn.classList.remove('is-pressed');
    }, true);
  });

  function showModal(title, text) {
    $('#join-modal-title').textContent = title || '–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è';
    $('#join-modal-text').textContent = text || '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
    $('#join-modal').classList.remove('hidden');
    setTimeout(() => $('#join-modal-ok')?.focus(), 0);
  }
  function hideModal() { $('#join-modal')?.classList.add('hidden'); }
  $('#join-modal-ok')?.addEventListener('click', hideModal);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      hideModal(); hideNet();
      const emojiPop = document.getElementById('emoji-pop');
      const mentionBox = document.getElementById('mentions-suggest');
      if (emojiPop) emojiPop.hidden = true;
      if (mentionBox) mentionBox.hidden = true;
    }
  });

  function showNet() { $('#net-popover').classList.remove('hidden'); $('#stun-input').value = localStorage.getItem('STUN') || ''; }
  function hideNet() { $('#net-popover').classList.add('hidden'); }
  $('#settings').addEventListener('click', showNet);
  $('#stun-save').addEventListener('click', () => { 
    const v = $('#stun-input').value.trim();
    if (v) localStorage.setItem('STUN', v); else localStorage.removeItem('STUN');
    toast('STUN —Å–æ—Ö—Ä–∞–Ω—ë–Ω'); hideNet();
  });
  $('#stun-reset').addEventListener('click', () => { localStorage.removeItem('STUN'); $('#stun-input').value = ''; toast('STUN —Å–±—Ä–æ—à–µ–Ω'); });

  // ---------- Emoji & Mentions ----------
  const emojiBtn = document.getElementById('emoji-btn');
  const emojiPop = document.getElementById('emoji-pop');
  const mentionBox = document.getElementById('mentions-suggest');
  const chatLog = document.getElementById('chat-log');
  const chatInput = document.getElementById('chat-input');
  const chatSend = document.getElementById('chat-send');

  const EMOJIS = 'üëç,üëé,üôÇ,üòâ,üòä,üòÇ,ü§£,üòÆ,üò¢,üò°,‚ù§,üî•,‚ú®,üéâ,‚úÖ,‚ùå,‚≠ê,üöÄ,üéß,üéµ,‚òé,üí°,üß†,üí¨,üçÄ,‚òï,üçï,üçé'.split(',');
  function buildEmojiPop() {
    emojiPop.innerHTML = '';
    const hdr = document.createElement('div');
    hdr.className = 'emoji-pop__hdr';
    const title = document.createElement('div');
    title.className = 'emoji-pop__title';
    title.textContent = '–≠–º–æ–¥–∑–∏';
    const close = document.createElement('button');
    close.type = 'button';
    close.className = 'emoji-pop__close';
    close.textContent = '√ó';
    close.title = '–ó–∞–∫—Ä—ã—Ç—å';
    close.addEventListener('click', () => { emojiPop.hidden = true; chatInput.focus(); });
    hdr.appendChild(title); hdr.appendChild(close);
    emojiPop.appendChild(hdr);
    const hr = document.createElement('hr'); emojiPop.appendChild(hr);
    EMOJIS.forEach(e => {
      const b = document.createElement('button');
      b.type = 'button'; b.textContent = e;
      b.addEventListener('click', () => { insertAtCursor(chatInput, e); emojiPop.hidden = true; chatInput.focus(); });
      emojiPop.appendChild(b);
    });
  }
  function insertAtCursor(input, text) {
    const start = input.selectionStart ?? input.value.length;
    const end = input.selectionEnd ?? input.value.length;
    const val = input.value;
    input.value = val.slice(0, start) + text + val.slice(end);
    const pos = start + text.length;
    input.setSelectionRange(pos, pos);
    input.dispatchEvent(new Event('input'));
  }
  emojiBtn?.addEventListener('click', () => { if (emojiPop.hidden) buildEmojiPop(); emojiPop.hidden = !emojiPop.hidden; });
  document.addEventListener('click', (e) => {
    if (!emojiPop.hidden && !emojiPop.contains(e.target) && e.target !== emojiBtn) emojiPop.hidden = true;
    if (!mentionBox.hidden && !mentionBox.contains(e.target)) mentionBox.hidden = true;
  });

  // ---------- Signaling: WebSocket ----------
  function setState(text, status='idle') {
    const el = document.getElementById('state');
    el.textContent = text;
    el.setAttribute('data-status', status);
  }
  const peersEl = document.getElementById('peers');
  const nameEl = document.getElementById('name');
  const joinBtn = document.getElementById('join');
  const tpl = document.getElementById('peer-tpl');

  const pcs    = new Map(); // id -> RTCPeerConnection
  const audios = new Map(); // id -> <audio>
  const dcs    = new Map(); // id -> RTCDataChannel (chat channel)
  let myId = null;
  let joined = false;
  let micStream = null;

  let rosterById = new Map();
  function updateRoster(roster) { rosterById = new Map(roster.map(p => [p.id, p.name || ""])); }

  const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws');
  ws.addEventListener('open',  () => setState('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'ok'));
  ws.addEventListener('close', () => setState('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ', 'warn'));
  ws.addEventListener('error', () => setState('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'error'));

  ws.addEventListener('message', async (ev) => {
    let m; try { m = JSON.parse(ev.data); } catch { return; }
    if (m.type === 'hello') {
      myId = m.id; updateRoster(m.roster || []);
      setState('–í –∫–æ–º–Ω–∞—Ç–µ', 'ok');
      (m.roster||[]).filter(p => p.id !== myId).forEach(p => addPeerUI(p.id, p.name));
      return;
    }
    if (m.type === 'roster') {
      updateRoster(m.roster || []);
      peersEl.innerHTML = '';
      (m.roster||[]).filter(p => p.id !== myId).forEach(p => addPeerUI(p.id, p.name));
      return;
    }
    if (m.type === 'peer-joined') {
      if (m.id !== myId) { addPeerUI(m.id); if (joined) maybeCall(m.id); toast('–ö—Ç–æ-—Ç–æ –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è'); }
      return;
    }
    if (m.type === 'peer-left') {
      removePeerUI(m.id); closePeer(m.id); toast('–ö—Ç–æ-—Ç–æ –≤—ã—à–µ–ª', 'warn'); return;
    }
    if (m.type === 'offer') {
      const from = m.from; const pc = pcs.get(from) || makePC(from);
      await pc.setRemoteDescription({ type:'offer', sdp:m.sdp });
      const ans = await pc.createAnswer();
      await pc.setLocalDescription(ans);
      ws.send(JSON.stringify({ type:'answer', to:from, sdp:pc.localDescription.sdp, sdpType:pc.localDescription.type }));
      return;
    }
    if (m.type === 'answer') {
      const pc = pcs.get(m.from); if (!pc) return;
      await pc.setRemoteDescription({ type:'answer', sdp:m.sdp });
      return;
    }
    if (m.type === 'ice') {
      const pc = pcs.get(m.from); if (!pc) return;
      const c = m.candidate;
      if (c === null) { try { await pc.addIceCandidate(null); } catch {} ; return; }
      if (!c.candidate || c.candidate.includes('.local')) return;
      try { await pc.addIceCandidate(c); } catch {}
      return;
    }
    if (m.type === 'full') {
      const cap = typeof m.capacity === 'number' ? m.capacity : undefined;
      const title = '–ö–æ–º–Ω–∞—Ç–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞';
      const text = cap ? `–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤: ${cap}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.` : '–ö–æ–º–Ω–∞—Ç–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.';
      showModal(title, text); try { ws.close(4001); } catch {}
      setState('–ö–æ–º–Ω–∞—Ç–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞', 'warn'); return;
    }
    if (m.type === 'browser-only') {
      showModal('–¢—Ä–µ–±—É–µ—Ç—Å—è –±—Ä–∞—É–∑–µ—Ä', '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –∏–∑ –±—Ä–∞—É–∑–µ—Ä–∞. –û—Ç–∫—Ä–æ–π—Ç–µ —Å—Å—ã–ª–∫—É –≤ Chrome/Firefox/Safari/Edge.');
      try { ws.close(4002); } catch {} setState('–¢–æ–ª—å–∫–æ –±—Ä–∞—É–∑–µ—Ä', 'error'); return;
    }
  });

  // ---------- UI: peers ----------
  function addPeerUI(id, name) {
    if (document.getElementById('peer-' + id)) return;
    const node = tpl.content.cloneNode(true);
    const root = node.querySelector('.peer'); root.id = 'peer-' + id;
    node.querySelector('.peer__name').textContent = name || id.slice(0,6);
    const audio = node.querySelector('audio');
    const muteBtn = node.querySelector('.mute');
    const vol = node.querySelector('.vol');
    muteBtn.onclick = () => {
      audio.muted = !audio.muted;
      muteBtn.textContent = audio.muted ? 'Unmute' : 'Mute';
      muteBtn.classList.toggle('is-on', audio.muted);
      muteBtn.setAttribute('aria-pressed', audio.muted ? 'true' : 'false');
    };
    vol.oninput = () => { audio.volume = (+vol.value)/100; };
    peersEl.appendChild(node);
    audios.set(id, audio);
  }
  function removePeerUI(id) {
    const el = document.getElementById('peer-' + id);
    if (el) { el.classList.add('bye'); setTimeout(()=>el.remove(), 300); }
    audios.delete(id);
  }

  function closePeer(id) {
    const pc = pcs.get(id);
    if (pc) { try { pc.getSenders().forEach(s=>s.track&&s.track.stop()); } catch{} try { pc.close(); } catch{} pcs.delete(id); }
    const dc = dcs.get(id); if (dc) { try { dc.close(); } catch{} dcs.delete(id); }
  }
  function closeAllPeers() {
    for (const id of Array.from(pcs.keys())) closePeer(id);
    peersEl.innerHTML = '';
  }

  // ---------- WebRTC: media + datachannel ----------
  function bindChatChannel(remoteId, ch) {
    dcs.set(remoteId, ch);
    ch.onopen = () => { toast('DC –æ—Ç–∫—Ä—ã—Ç —Å ' + (rosterById.get(remoteId)||remoteId.slice(0,6))); };
    ch.onclose = () => { dcs.delete(remoteId); };
    ch.onmessage = (ev) => {
      try {
        const msg = JSON.parse(ev.data);
        if (msg && msg.type === 'chat' && typeof msg.text === 'string') {
          appendChat({from: msg.from, name: msg.name, text: msg.text, ts: msg.ts});
        }
      } catch {}
    };
  }

  function makePC(remoteId) {
    const stun = localStorage.getItem('STUN') || 'stun:stun.l.google.com:19302';
    const pc = new RTCPeerConnection({ iceServers: [{ urls: [stun] }] });
    pcs.set(remoteId, pc);
    if (micStream) micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

    pc.ontrack = (ev) => {
      const [stream] = ev.streams;
      addPeerUI(remoteId);
      const audio = audios.get(remoteId);
      audio.srcObject = stream;
      audio.volume = 0; const target = 1; let v = 0;
      const tick = () => { v = Math.min(target, v + 0.05); audio.volume = v; if (v < target) requestAnimationFrame(tick); };
      requestAnimationFrame(tick);
    };
    pc.onicecandidate = (e) => {
      ws.send(JSON.stringify({ type:'ice', to:remoteId, candidate: e.candidate ? {
        candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex
      } : null }));
    };
    pc.ondatachannel = (ev) => {
      if (ev.channel && ev.channel.label === 'chat') bindChatChannel(remoteId, ev.channel);
    };

    // –ò–Ω–∏—Ü–∏–∞—Ç–æ—Ä (–±–û–ª—å—à–∏–π id) —Å–æ–∑–¥–∞—ë—Ç datachannel –¥–æ offer
    if (myId && myId > remoteId) {
      const ch = pc.createDataChannel('chat', {ordered:true, negotiated:false});
      bindChatChannel(remoteId, ch);
    }
    return pc;
  }

  async function maybeCall(remoteId) {
    if (myId < remoteId && joined) {
      const pc = pcs.get(remoteId) || makePC(remoteId);
      const off = await pc.createOffer();
      await pc.setLocalDescription(off);
      ws.send(JSON.stringify({ type:'offer', to:remoteId, sdp:pc.localDescription.sdp, sdpType:pc.localDescription.type }));
    }
  }

  // ---------- Chat helpers (UI) ----------
  function fmtTime(ts) { try { const d = new Date(ts); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); } catch { return ''; } }
  function appendChat({from: fromId, name, text, ts}) {
    const mine = (fromId === myId);
    const row = document.createElement('div'); row.className = 'chat__msg' + (mine ? ' mine' : '');
    const meta = document.createElement('span'); meta.className = 'meta';
    const who = name ? name : (fromId ? fromId.slice(0,6) : 'anon');
    meta.textContent = `${who} ¬∑ ${fmtTime(ts)}`;
    const body = document.createElement('span'); body.className = 'body'; body.textContent = ' ' + text;
    row.appendChild(meta); row.appendChild(body);
    chatLog.appendChild(row); chatLog.scrollTop = chatLog.scrollHeight;
  }

  function extractMentions(text) {
    const ids = []; const re = /@([\w\-]{1,32})/g; let m;
    while ((m = re.exec(text)) !== null) {
      const label = m[1].toLowerCase();
      for (const [id, name] of rosterById.entries()) {
        const shortId = id.slice(0,6).toLowerCase();
        if ((name && name.toLowerCase() === label) || shortId === label) { ids.push(id); break; }
      }
    }
    return Array.from(new Set(ids));
  }

  function sendChat(){
    const text = (chatInput.value||"").trim(); if(!text) return;
    const msg = { type:'chat', text, from: myId, name: (nameEl.value||'User').slice(0,32), ts: Date.now(), mentions: extractMentions(text) };
    appendChat(msg); // –ª–æ–∫–∞–ª—å–Ω–æ —Å—Ä–∞–∑—É
    // —Ä–∞–∑–æ—Å–ª–∞—Ç—å –ø–æ –≤—Å–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–º DataChannel
    for (const [id, ch] of dcs) { if (ch.readyState === 'open') { try { ch.send(JSON.stringify(msg)); } catch {} } }
    chatInput.value = "";
  }
  chatSend?.addEventListener('click', sendChat);
  chatInput?.addEventListener('keydown', (e) => { if (e.key === 'Enter') { e.preventDefault(); sendChat(); } });

  // ---------- Join / Leave ----------
  function switchJoinButton(toState) {
    const label = joinBtn.querySelector('.btn__label');
    if (toState === 'leave') {
      joinBtn.dataset.mode = 'leave'; joinBtn.classList.remove('primary','glow');
      joinBtn.classList.add('danger','is-on'); joinBtn.setAttribute('aria-pressed','true'); label.textContent = '–í—ã–π—Ç–∏';
    } else {
      joinBtn.dataset.mode = 'join'; joinBtn.classList.remove('danger','is-on');
      joinBtn.classList.add('primary','glow'); joinBtn.setAttribute('aria-pressed','false'); label.textContent = '–í–æ–π—Ç–∏';
    }
  }

  async function startCall() {
    try {
      setState('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –º–∏–∫—Ä–æ—Ñ–æ–Ω‚Ä¶', 'idle');
      micStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      ws.send(JSON.stringify({ type:'name', name: (nameEl.value || 'User').slice(0, 32) }));
      joined = true;
      // –ü–æ–∑–≤–æ–Ω–∏—Ç—å –≤—Å–µ–º —É–∂–µ –≤–∏–¥–∏–º—ã–º
      $$('.peer').forEach(el => { const id = el.id.replace('peer-',''); const pc = pcs.get(id) || makePC(id); });
      for (const el of $$('.peer')) { const id = el.id.replace('peer-',''); maybeCall(id); }
      toast('–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω');
      setState('–í—ã –≤ —ç—Ñ–∏—Ä–µ', 'ok');
      switchJoinButton('leave');
    } catch (e) {
      toast('–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–ø—Ä–µ—â—ë–Ω', 'error');
      setState('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'error');
      switchJoinButton('join');
    }
  }

  async function leaveCall() {
    try {
      joined = false;
      if (micStream) { for (const t of micStream.getTracks()) { try { t.stop(); } catch {} } micStream = null; }
      closeAllPeers();
      setState('–í—ã –≤—ã—à–ª–∏ –∏–∑ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞', 'warn');
      toast('–í—ã –≤—ã—à–ª–∏ –∏–∑ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞', 'warn');
    } finally {
      switchJoinButton('join');
    }
  }

  joinBtn.onclick = async () => {
    if (joinBtn.dataset.mode === 'join' && !joined) { await startCall(); }
    else if (joinBtn.dataset.mode === 'leave') { await leaveCall(); }
  };

  </script>
</body>
</html>
